● 프로세스와 스레드

프로그램의 실행이란 프로그램을 구성하는 코드를 순서대로 CPU에서 연산(실행)하는 일이다.
초창기의 컴퓨터는 한 번에 하나의 프로그램만 실행했는데 이를 해결하기 위해 하나의 CPU 코어로 여러 프로그램을 동시에 실행하는 '멀티태스킹' 기술이 등장했다

• 멀티 태스킹

단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미한다.

• 멀티 프로세싱  

여러 CPU(여러 CPU 코어)를 사용하여 동시에 여러 작업을 수행하는 것을 의미한다


멀티프로세싱은 하드웨어 장비의 관점이고, 멀티태스킹은 운영체제 소프트웨어의 관점이다.

• 프로세스

실행 중인 프로그램의 인스턴스이다.
각 프로세스는 독립적인 메모리 공간을 갖고 있으며 서로 간섭하지 않으며 서로에게 영향을 미치지 않는다

• 프로세스의 메모리 구성

코드 섹션 : 실행할 프로그램의 코드가 저장되는 부분
데이터 섹션 : : 전역 변수 및 정적 변수가 저장되는 부분
힙 (Heap) : 동적으로 할당되는 메모리 영역
스택 (Stack) : 메서드(함수) 호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)

• 스레드

스레드는 프로세스 내에서 실행되는 작업의 단위이다.
프로세스는 하나 이상의 스레드를 반드시 포함한다.

• 스레드는 단일스레드와 멀티스레드로 구분된다

단일 스레드 : 한 프로세스 내에 하나의 스레드만 존재
멀티 스레드 : 한 프로세스 내에 여러 스레드가 존재

• 멀티스레드가 필요한 이유

하나의 프로그램도 그 안에서 동시에 여러 작업이 필요하기 때문  
ex) 워드 프로그램으로 문서를 편집하면서, 문서가 자동으로 저장되고, 맞춤법 검사도 함께 수행된다

• 프로세스와 스레드

프로세스는 실행 환경과 자원을 제공하는 컨테이너 역할을 하고, 실제 CPU를 사용해서 코드를 하나하나 실행하는 것은 스레드이다.

• 컨텍스트 스위칭

하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 작업

멀티스레드는 대부분 효율적이지만, 컨텍스트 스위칭 과정이 필요하므로 항상 효율적인 것은 아니다

• 스레드가 하는 작업

CPU-바운드 작업 (CPU-bound tasks) : CPU의 연산 능력을 많이 요구하는 작업
I/O-바운드 작업 (I/O-bound tasks) : 입출력(I/O) 작업을 많이 요구하는 작업

실무에서는 I/O-바운드 작업이 많다.
스레드의 숫자는 CPU-바운드 작업이 많은가, 아니면 I/O-바운드 작업이 많은가에 따라 다르게 설정해야한다

CPU-바운드 작업 : CPU 코어 수 + 1개
I/O-바운드 작업 : CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성



● 스레드 생성과 실행

• 자바 메모리 구조

메서드영역 :  프로그램을 실행하는데 필요한 공통 데이터를 관리
스택영역 : 자바 실행 시, 하나의 실행 스택이 생성
힙영역 :  객체(인스턴스)와 배열이 생성되는 영역

• 스레드 생성 방법 2가지

Thread 클래스를 상속 받는 방법, Runnable 인터페이스를 구현하는 방법 

• Thread 클래스를 상속 받기

Thread 클래스

public class HelloThread extends Thread {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ": run()");
    }
    
 }

 main 클래스

 package thread.start;
 
 public class HelloThreadMain {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");
        
        HelloThread helloThread = new HelloThread();
        helloThread.start();  // 중요 !!

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }
 }

run() 메서드가 아니라 반드시 "start()" 메서드를 호출해야 한다
스레드 객체를 생성하고, 반드시 start()를 호출해야 스택 공간을 할당 받고 스레드가 작동한다.
핵심은 Thread-0스레드가 run() 메서드를 실행한다는 점이다. (run() 메서드를 호출하면 main 스레드가 실행)

메서드를 실행하면 스택 위에 스택 프레임이 쌓인다

• Runnable 인터페이스를 구현하기

Runnable 클래스

 public class HelloRunnable implements Runnable {
 
    @Override
 public void run() {
 System.out.println(Thread.currentThread().getName() + ": run()");
    }
    
 }

Main 클래스

public class HelloRunnableMain {
   public static void main(String[] args) {
   
   System.out.println(Thread.currentThread().getName() + ": main() start");
 
   HelloRunnable runnable = new HelloRunnable();
   Thread thread = new Thread(runnable);
   thread.start();
   
   System.out.println(Thread.currentThread().getName() + ": main() end");
 
    }
 }

• Thread 상속 vs Runnable 구현

스레드 사용할 때는 Thread 를 상속 받는 방법보다 Runnable 인터페이스를 구현하는 방식을 사용하자
Thread를 상속받을시 상속의 제한(이미 Thread를 상속받기 때문,Java는 단일상속) 이 생기고 코드 유연성이 부족해진다.

• 여러 스레드 만들기

public class ManyThreadMainV2 {

    public static void main(String[] args) {
    
        log("main() start");
        
        HelloRunnable runnable = new HelloRunnable();
        for (int i = 0; i < 100; i++) {
            Thread thread = new Thread(runnable);
            thread.start();
        }
        
        log("main() end");
    }
}     

반복문을 사용하면 스레드의 숫자를 유동적으로 변경하면서 실행할 수 있다

• Runnable을 만드는 다양한 방법

· 중첩 클래스

public static void main(String[] args) {

     log("main() start");
     
     Runnable runnable = new MyRunnable();
     Thread thread = new Thread(runnable);
     thread.start();
     
     log("main() end");
}

 static class MyRunnable implements Runnable {
 
        @Override
        public void run() {
            log("run()");
        }
        
    }
 }

· 익명 클래스

 public static void main(String[] args) {
 
        log("main() start");
        
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                log("run()");
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
        
        log("main() end");
    }
 }
 
• 데몬 스레드

스레드는 사용자(user) 스레드와 데몬(daemon) 스레드 2가지 종류로 구분할 수 있다

· 사용자 스레드(non-daemon 스레드)

프로그램의 주요 작업을 수행한다
작업이 완료될 때까지 실행된다.

· 데몬(daemon) 스레드

백그라운드에서 보조적인 작업을 수행한다.
모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다


